[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial source changes: [0m
[0m[[0m[0mdebug[0m] [0m[0m	removed:Set(/home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/3.aritmethicOperations.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/14.forLoops.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/12.logicalOperators.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/2.datatypes.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/7.arrays.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/16.DeclaringFunctions.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/6.lists.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/17.singletonObjects.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/5.tuples.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/8.sets.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/11.flattenFlatMap.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/15.whileLoops.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/13.ifStatement.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/1.definedFunctions.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/9.maps.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/10.mapMethod.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/4.stringOperations.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	added: Set(/home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/ForLoops.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/FlattenMap.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/DefinedFunctions.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Functions.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Exceptions.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/CaseObjects.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/ClassDefinition.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Options.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/PatternMatching.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Traits.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/AritmethicOperations.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Sets.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/SingletonObjects.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/CollectionsFunctions.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Volatile.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Lists.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/ComposingHOFs.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Arrays.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/LogicOperators.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Futures.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/DataTypes.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/SynteticMethods.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Tuples.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/LambdaFunctions.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/CaseClasses.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/StringOperators.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/WhileLoops.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/IfStatement.scala, /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/src/main/scala/examples/Maps.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	modified: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated products: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mExternal API changes: API Changes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mModified binary dependencies: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial directly invalidated classes: Set(examples.aritmethicOperationsTest, examples.setsTest, examples.functionsTests.functions, examples.singletonTest, examples.arraysTests, examples.foorLoopsTest, examples.wileLoopsTest, examples.listsTests, examples.definedFunctionsTest, examples.stringOperatorsTest, examples.datatypesTest, examples.logicOperatorsTest, examples.functionsTests, examples.tuplesTest, examples.lambdaFunctionsTest, examples.mapsTest, examples.ifstatementTest, examples.flattenTests)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mSources indirectly invalidated by:[0m
[0m[[0m[0mdebug[0m] [0m[0m	product: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	binary dep: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	external source: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll sources are invalidated.[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.aritmethicOperationsTest, examples.setsTest, examples.functionsTests.functions, examples.singletonTest, examples.arraysTests, examples.foorLoopsTest, examples.wileLoopsTest, examples.listsTests, examples.definedFunctionsTest, examples.stringOperatorsTest, examples.datatypesTest, examples.logicOperatorsTest, examples.functionsTests, examples.tuplesTest, examples.lambdaFunctionsTest, examples.mapsTest, examples.ifstatementTest, examples.flattenTests[0m
[0m[[0m[0mdebug[0m] [0m[0mRecompiling all sources: number of invalidated sources > 50.0% of all sources[0m
[0m[[0m[0minfo[0m] [0m[0mCompiling 29 Scala sources to /home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/target/scala-2.13/classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.13:1.3.5:compile for Scala 2.13.1[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.13:1.3.5:compile for Scala 2.13.1[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] Running cached compiler 387935f2 for Scala compiler version 2.13.1[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] The Scala compiler is invoked with:[0m
[0m[[0m[0mdebug[0m] [0m[0m	-bootclasspath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/home/daniel/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.1/scala-library-2.13.1.jar[0m
[0m[[0m[0mdebug[0m] [0m[0m	-classpath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/home/daniel/Desktop/Projects/study/4.ScalaLearning/scalaLearning/Basis/target/scala-2.13/classes[0m
[0m[[0m[0mdebug[0m] [0m[0mScala compilation took 6.500177379 s[0m
[0m[[0m[0mdebug[0m] [0m[0mDone compiling.[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.arraysTests...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.arraysTests[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.arraysTests)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.arraysTests,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(arraysTests,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.arraysTests has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(arraysTests,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.arraysTests)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.OffTime1...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.OffTime1[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.OffTime1)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.OffTime1,ModifiedNames(changes = UsedName(examples;OffTime1;init;,[Default]), UsedName(unapply,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(productElementNames,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(name,[Default]), UsedName(lunchTime,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(breakTime,[Default]), UsedName(productIterator,[Default]), UsedName(copy$default$3,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(copy$default$1,[Default]), UsedName(OffTime1,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.OffTime1 has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(examples;OffTime1;init;,[Default]), UsedName(unapply,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(productElementNames,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(name,[Default]), UsedName(lunchTime,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(breakTime,[Default]), UsedName(productIterator,[Default]), UsedName(copy$default$3,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(copy$default$1,[Default]), UsedName(OffTime1,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.OffTime1)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Customer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Customer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Customer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Customer,ModifiedNames(changes = UsedName(unapply,[Default]), UsedName(firstName,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(examples;Customer;init;,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName(lastName,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(copy$default$1,[Default]), UsedName(eq,[Default]), UsedName(Customer,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Customer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(unapply,[Default]), UsedName(firstName,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(examples;Customer;init;,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName(lastName,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(copy$default$1,[Default]), UsedName(eq,[Default]), UsedName(Customer,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Customer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.mapsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.mapsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.mapsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.mapsTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(mapsTest,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.mapsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(mapsTest,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.mapsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.CaseObjects...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.CaseObjects[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.CaseObjects)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.CaseObjects,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(CaseObjects,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(caseObj,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.CaseObjects has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(CaseObjects,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(caseObj,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.CaseObjects)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.definedFunctionsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.definedFunctionsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.definedFunctionsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.definedFunctionsTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(definedFunctionsTest,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.definedFunctionsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(definedFunctionsTest,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.definedFunctionsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.functionsTests.functions...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.functionsTests.functions[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.functionsTests.functions)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.functionsTests.functions,ModifiedNames(changes = UsedName(isPrime,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(sum,[Default]), UsedName(divide,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(examples;functionsTests;functions;init;,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(sumDefined,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(anothersum,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(functions,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.functionsTests.functions has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(isPrime,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(sum,[Default]), UsedName(divide,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(examples;functionsTests;functions;init;,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(sumDefined,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(anothersum,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(functions,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.functionsTests.functions)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.StringOperators...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.StringOperators[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.StringOperators)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.StringOperators,ModifiedNames(changes = UsedName(len,[Default]), UsedName(cnts,[Default]), UsedName(slc,[Default]), UsedName(string2,[Default]), UsedName(wait,[Default]), UsedName(las,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(pos,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(StringOperators,[Default]), UsedName(string3,[Default]), UsedName(hosieryAd,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(search,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(animal,[Default]), UsedName(eq,[Default]), UsedName(mch,[Default]), UsedName(string1,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.StringOperators has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(len,[Default]), UsedName(cnts,[Default]), UsedName(slc,[Default]), UsedName(string2,[Default]), UsedName(wait,[Default]), UsedName(las,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(pos,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(StringOperators,[Default]), UsedName(string3,[Default]), UsedName(hosieryAd,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(search,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(animal,[Default]), UsedName(eq,[Default]), UsedName(mch,[Default]), UsedName(string1,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.StringOperators)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Arrays...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Arrays[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Arrays)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Arrays,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(Arrays,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(arrang,[Default]), UsedName(n,[Default]), UsedName(arr2,[Default]), UsedName(obj,[Default]), UsedName(arr1,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(fruits,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Arrays has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(Arrays,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(arrang,[Default]), UsedName(n,[Default]), UsedName(arr2,[Default]), UsedName(obj,[Default]), UsedName(arr1,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(fruits,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Arrays)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Tuples...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Tuples[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Tuples)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Tuples,ModifiedNames(changes = UsedName(t,[Default]), UsedName(junkTup,[Default]), UsedName(wait,[Default]), UsedName(Tuples,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(t3,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(e2,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(e1,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(t2,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Tuples has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(t,[Default]), UsedName(junkTup,[Default]), UsedName(wait,[Default]), UsedName(Tuples,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(t3,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(e2,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(e1,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(t2,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Tuples)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.exampleCaseObject...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.exampleCaseObject[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.exampleCaseObject)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.exampleCaseObject,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(productPrefix,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(productElementNames,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(exampleCaseObject,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.exampleCaseObject has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(productPrefix,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(productElementNames,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(exampleCaseObject,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.exampleCaseObject)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.ComposingHOFs...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.ComposingHOFs[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.ComposingHOFs)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.ComposingHOFs,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(myNums,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(ComposingHOFs,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.ComposingHOFs has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(myNums,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(ComposingHOFs,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.ComposingHOFs)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Hello...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Hello[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Hello)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Hello,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(Hello,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(examples;Hello;init;,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Hello has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(Hello,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(examples;Hello;init;,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Hello)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.ExampleTrait...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.ExampleTrait[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.ExampleTrait)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.ExampleTrait,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName(ExampleTrait,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.ExampleTrait has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName(ExampleTrait,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.ExampleTrait)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.HelloMessage...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.HelloMessage[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.HelloMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.HelloMessage,ModifiedNames(changes = UsedName(myMsg,[Default]), UsedName(HelloMessage,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(message2,[Default]), UsedName(finalize,[Default]), UsedName(defaultMsg,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(message,[Default]), UsedName(<init>$default$2,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(examples;HelloMessage;init;,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.HelloMessage has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(myMsg,[Default]), UsedName(HelloMessage,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(message2,[Default]), UsedName(finalize,[Default]), UsedName(defaultMsg,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(message,[Default]), UsedName(<init>$default$2,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(examples;HelloMessage;init;,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.HelloMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.foorLoopsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.foorLoopsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.foorLoopsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.foorLoopsTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(foorLoopsTest,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.foorLoopsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(foorLoopsTest,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.foorLoopsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.exampleCaseClass...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.exampleCaseClass[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.exampleCaseClass)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.exampleCaseClass,ModifiedNames(changes = UsedName(unapply,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hours,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(hashCode,[Default]), UsedName(minutes,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(examples;exampleCaseClass;init;,[Default]), UsedName(copy$default$1,[Default]), UsedName(exampleCaseClass,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.exampleCaseClass has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(unapply,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hours,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(hashCode,[Default]), UsedName(minutes,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(examples;exampleCaseClass;init;,[Default]), UsedName(copy$default$1,[Default]), UsedName(exampleCaseClass,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.exampleCaseClass)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.tuplesTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.tuplesTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.tuplesTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.tuplesTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(tuplesTest,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.tuplesTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(tuplesTest,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.tuplesTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.PatternMatching...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.PatternMatching[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.PatternMatching)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.PatternMatching,ModifiedNames(changes = UsedName(PatternMatching,[Default]), UsedName(getMiddleName,[Default]), UsedName(wait,[Default]), UsedName(isCustomer,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(p,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(Provider,[Default]), UsedName(eq,[Default]), UsedName(Customer,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.PatternMatching has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(PatternMatching,[Default]), UsedName(getMiddleName,[Default]), UsedName(wait,[Default]), UsedName(isCustomer,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(p,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(Provider,[Default]), UsedName(eq,[Default]), UsedName(Customer,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.PatternMatching)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.DataTypes...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.DataTypes[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.DataTypes)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.DataTypes,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(bf,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(al,[Default]), UsedName(DataTypes,[Default]), UsedName(aa,[Default]), UsedName(synchronized,[Default]), UsedName(d,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(ch,[Default]), UsedName(g,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(f,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.DataTypes has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(bf,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(al,[Default]), UsedName(DataTypes,[Default]), UsedName(aa,[Default]), UsedName(synchronized,[Default]), UsedName(d,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(ch,[Default]), UsedName(g,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(f,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.DataTypes)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.reverseTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.reverseTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.reverseTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.reverseTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(reverseTest,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.reverseTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(reverseTest,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.reverseTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.AritmethicOperations...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.AritmethicOperations[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.AritmethicOperations)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.AritmethicOperations,ModifiedNames(changes = UsedName(AritmethicOperations,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(h,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(e,[Default]), UsedName(synchronized,[Default]), UsedName(d,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(g,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(f,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.AritmethicOperations has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(AritmethicOperations,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(h,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(e,[Default]), UsedName(synchronized,[Default]), UsedName(d,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(g,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(f,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.AritmethicOperations)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.PatternMatching.Provider...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.PatternMatching.Provider[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.PatternMatching.Provider)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.PatternMatching.Provider,ModifiedNames(changes = UsedName(unapply,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName(last,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(middleName,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(copy$default$3,[Default]), UsedName(examples;PatternMatching;Provider;init;,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(copy$default$1,[Default]), UsedName(Provider,[Default]), UsedName(apply$default$3,[Default]), UsedName(first,[Default]), UsedName(eq,[Default]), UsedName(<init>$default$3,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.PatternMatching.Provider has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(unapply,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName(last,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(middleName,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(copy$default$3,[Default]), UsedName(examples;PatternMatching;Provider;init;,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(copy$default$1,[Default]), UsedName(Provider,[Default]), UsedName(apply$default$3,[Default]), UsedName(first,[Default]), UsedName(eq,[Default]), UsedName(<init>$default$3,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.PatternMatching.Provider)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.ifstatementTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.ifstatementTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.ifstatementTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.ifstatementTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ifstatementTest,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.ifstatementTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ifstatementTest,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.ifstatementTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from SynteticMethods...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: SynteticMethods[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(SynteticMethods)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(SynteticMethods,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(time2,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(time,[Default]), UsedName(!=,[Default]), UsedName(Time,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(SynteticMethods,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The SynteticMethods has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(time2,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(time,[Default]), UsedName(!=,[Default]), UsedName(Time,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(SynteticMethods,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(SynteticMethods)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.flattenTests...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.flattenTests[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.flattenTests)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.flattenTests,ModifiedNames(changes = UsedName(flattenTests,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.flattenTests has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(flattenTests,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.flattenTests)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.lambdaFunctionsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.lambdaFunctionsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.lambdaFunctionsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.lambdaFunctionsTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(lambdaFunctionsTest,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.lambdaFunctionsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(lambdaFunctionsTest,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.lambdaFunctionsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.stringOperatorsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.stringOperatorsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.stringOperatorsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.stringOperatorsTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(stringOperatorsTest,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.stringOperatorsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(stringOperatorsTest,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.stringOperatorsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.functionsTests...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.functionsTests[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.functionsTests)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.functionsTests,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(functions,[Default]), UsedName(eq,[Default]), UsedName(functionsTests,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.functionsTests has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(functions,[Default]), UsedName(eq,[Default]), UsedName(functionsTests,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.functionsTests)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.datatypesTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.datatypesTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.datatypesTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.datatypesTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(datatypesTest,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.datatypesTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(datatypesTest,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.datatypesTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Futures...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Futures[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Futures)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Futures,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(ec,[Implicit]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(timeout,[Implicit]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(Futures,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Futures has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(ec,[Implicit]), UsedName(timeout,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Futures)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Lists...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Lists[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Lists)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Lists,ModifiedNames(changes = UsedName(Lists,[Default]), UsedName(animals3,[Default]), UsedName(tl,[Default]), UsedName(slc,[Default]), UsedName(hd,[Default]), UsedName(wait,[Default]), UsedName(numbers,[Default]), UsedName(pro,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(stuff1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(newNumbers,[Default]), UsedName(finalize,[Default]), UsedName(ma,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(su,[Default]), UsedName(newNumbers2,[Default]), UsedName(n,[Default]), UsedName(m,[Default]), UsedName(animals2,[Default]), UsedName(synchronized,[Default]), UsedName(combo,[Default]), UsedName(isInstanceOf,[Default]), UsedName(animals,[Default]), UsedName(s,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(tk,[Default]), UsedName(lstTuples,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(ctns,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Lists has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Lists,[Default]), UsedName(animals3,[Default]), UsedName(tl,[Default]), UsedName(slc,[Default]), UsedName(hd,[Default]), UsedName(wait,[Default]), UsedName(numbers,[Default]), UsedName(pro,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(stuff1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(newNumbers,[Default]), UsedName(finalize,[Default]), UsedName(ma,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(su,[Default]), UsedName(newNumbers2,[Default]), UsedName(n,[Default]), UsedName(m,[Default]), UsedName(animals2,[Default]), UsedName(synchronized,[Default]), UsedName(combo,[Default]), UsedName(isInstanceOf,[Default]), UsedName(animals,[Default]), UsedName(s,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(tk,[Default]), UsedName(lstTuples,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(ctns,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Lists)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.singletonTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.singletonTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.singletonTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.singletonTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(singletonTest,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.singletonTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(singletonTest,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.singletonTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Volatile...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Volatile[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Volatile)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Volatile,ModifiedNames(changes = UsedName(Volatile,[Default]), UsedName(customer,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Volatile has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Volatile,[Default]), UsedName(customer,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Volatile)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.DefinedFunctions...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.DefinedFunctions[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.DefinedFunctions)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.DefinedFunctions,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(DefinedFunctions,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.DefinedFunctions has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(DefinedFunctions,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.DefinedFunctions)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from SynteticMethods.Time...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: SynteticMethods.Time[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(SynteticMethods.Time)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(SynteticMethods.Time,ModifiedNames(changes = UsedName(unapply,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName(SynteticMethods;Time;init;,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hours,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(Time,[Default]), UsedName(hashCode,[Default]), UsedName(minutes,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(copy$default$1,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The SynteticMethods.Time has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(unapply,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName(SynteticMethods;Time;init;,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(hours,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(Time,[Default]), UsedName(hashCode,[Default]), UsedName(minutes,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(copy$default$1,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(SynteticMethods.Time)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.WhileLoops...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.WhileLoops[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.WhileLoops)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.WhileLoops,ModifiedNames(changes = UsedName(whilebreak,[Default]), UsedName(x,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(k,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(WhileLoops,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.WhileLoops has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(whilebreak,[Default]), UsedName(x,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(k,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(WhileLoops,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.WhileLoops)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Reverse...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Reverse[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Reverse)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Reverse,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(Reverse,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Reverse has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(Reverse,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Reverse)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.HelloObject...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.HelloObject[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.HelloObject)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.HelloObject,ModifiedNames(changes = UsedName(HelloObject,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(echo,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.HelloObject has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(HelloObject,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(echo,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.HelloObject)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Functions...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Functions[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Functions)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Functions,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(func,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(Functions,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(functions,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Functions has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(func,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(Functions,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(functions,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Functions)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Maps...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Maps[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Maps)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Maps,ModifiedNames(changes = UsedName(animalsMutable,[Default]), UsedName(valueAnimal,[Default]), UsedName(Maps,[Default]), UsedName(listy,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(numbersMap,[Default]), UsedName(fruitsMap,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(mapFruitsAnimals,[Default]), UsedName(synchronized,[Default]), UsedName(animalsMap,[Default]), UsedName(isInstanceOf,[Default]), UsedName(otherMap,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(animal,[Default]), UsedName(mapyL,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Maps has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(animalsMutable,[Default]), UsedName(valueAnimal,[Default]), UsedName(Maps,[Default]), UsedName(listy,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(numbersMap,[Default]), UsedName(fruitsMap,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(mapFruitsAnimals,[Default]), UsedName(synchronized,[Default]), UsedName(animalsMap,[Default]), UsedName(isInstanceOf,[Default]), UsedName(otherMap,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(animal,[Default]), UsedName(mapyL,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Maps)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.logicOperatorsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.logicOperatorsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.logicOperatorsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.logicOperatorsTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(logicOperatorsTest,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.logicOperatorsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(logicOperatorsTest,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.logicOperatorsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Functions.functions...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Functions.functions[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Functions.functions)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Functions.functions,ModifiedNames(changes = UsedName(isPrime,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(sum,[Default]), UsedName(divide,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(sumDefined,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(anothersum,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(functions,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(examples;Functions;functions;init;,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Functions.functions has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(isPrime,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(sum,[Default]), UsedName(divide,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(sumDefined,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(anothersum,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(functions,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(examples;Functions;functions;init;,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Functions.functions)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Obtions...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Obtions[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Obtions)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Obtions,ModifiedNames(changes = UsedName(Obtions,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(opt,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(none,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Obtions has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Obtions,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(opt,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(none,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Obtions)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.ForLoops...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.ForLoops[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.ForLoops)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.ForLoops,ModifiedNames(changes = UsedName(badgers,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(range2,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(myNums,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ForLoops,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(myNums2,[Default]), UsedName(asInstanceOf,[Default]), UsedName(languages,[Default]), UsedName(!=,[Default]), UsedName(range1,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.ForLoops has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(badgers,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(range2,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(myNums,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ForLoops,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(myNums2,[Default]), UsedName(asInstanceOf,[Default]), UsedName(languages,[Default]), UsedName(!=,[Default]), UsedName(range1,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.ForLoops)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.SingletonExample...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.SingletonExample[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.SingletonExample)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.SingletonExample,ModifiedNames(changes = UsedName(SingletonExample,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(n,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.SingletonExample has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(SingletonExample,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(n,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.SingletonExample)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.setsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.setsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.setsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.setsTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(setsTest,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.setsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(setsTest,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.setsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.CollectionsFunctions...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.CollectionsFunctions[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.CollectionsFunctions)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.CollectionsFunctions,ModifiedNames(changes = UsedName(ea,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(ee,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(ei,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(e,[Default]), UsedName(ab,[Default]), UsedName(eh,[Default]), UsedName(ba,[Default]), UsedName(aa,[Default]), UsedName(CollectionsFunctions,[Default]), UsedName(synchronized,[Default]), UsedName(bb,[Default]), UsedName(d,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eg,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(ec,[Default]), UsedName(ef,[Default]), UsedName(eq,[Default]), UsedName(eb,[Default]), UsedName(ed,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.CollectionsFunctions has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(ea,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(ee,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(ei,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(e,[Default]), UsedName(ab,[Default]), UsedName(eh,[Default]), UsedName(ba,[Default]), UsedName(aa,[Default]), UsedName(CollectionsFunctions,[Default]), UsedName(synchronized,[Default]), UsedName(bb,[Default]), UsedName(d,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(eg,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(ec,[Default]), UsedName(ef,[Default]), UsedName(eq,[Default]), UsedName(eb,[Default]), UsedName(ed,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.CollectionsFunctions)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Exceptions...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Exceptions[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Exceptions)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Exceptions,ModifiedNames(changes = UsedName(makeInt,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(Exceptions,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(toInt,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Exceptions has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(makeInt,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(Exceptions,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(toInt,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Exceptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.FlattenMap...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.FlattenMap[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.FlattenMap)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.FlattenMap,ModifiedNames(changes = UsedName(numbersFlat,[Default]), UsedName(FlattenMap,[Default]), UsedName(wait,[Default]), UsedName(numbers,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(basicNumbers,[Default]), UsedName(##,[Default]), UsedName(basicToTwo,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(numbersFatMap,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.FlattenMap has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(numbersFlat,[Default]), UsedName(FlattenMap,[Default]), UsedName(wait,[Default]), UsedName(numbers,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(basicNumbers,[Default]), UsedName(##,[Default]), UsedName(basicToTwo,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(numbersFatMap,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.FlattenMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.LambdaFunctions...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.LambdaFunctions[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.LambdaFunctions)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.LambdaFunctions,ModifiedNames(changes = UsedName(numbersList2,[Default]), UsedName(wait,[Default]), UsedName(numbers,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(LambdaFunctions,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(cars,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(eq,[Default]), UsedName(cl,[Default]), UsedName(numbersList,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.LambdaFunctions has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(numbersList2,[Default]), UsedName(wait,[Default]), UsedName(numbers,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(LambdaFunctions,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(cars,[Default]), UsedName(!=,[Default]), UsedName(c,[Default]), UsedName(b,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(eq,[Default]), UsedName(cl,[Default]), UsedName(numbersList,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.LambdaFunctions)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.LogicOperators...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.LogicOperators[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.LogicOperators)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.LogicOperators,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(n,[Default]), UsedName(m,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(eq,[Default]), UsedName(LogicOperators,[Default]), UsedName(o,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.LogicOperators has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(n,[Default]), UsedName(m,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(a,[Default]), UsedName(eq,[Default]), UsedName(LogicOperators,[Default]), UsedName(o,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.LogicOperators)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.aritmethicOperationsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.aritmethicOperationsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.aritmethicOperationsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.aritmethicOperationsTest,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(aritmethicOperationsTest,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.aritmethicOperationsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(aritmethicOperationsTest,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.aritmethicOperationsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.OffTime...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.OffTime[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.OffTime)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.OffTime,ModifiedNames(changes = UsedName(examples;OffTime;init;,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(name,[Default]), UsedName(lunchTime,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(breakTime,[Default]), UsedName(OffTime,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.OffTime has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(examples;OffTime;init;,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(name,[Default]), UsedName(lunchTime,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(breakTime,[Default]), UsedName(OffTime,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.OffTime)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.PatternMatching.Customer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.PatternMatching.Customer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.PatternMatching.Customer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.PatternMatching.Customer,ModifiedNames(changes = UsedName(unapply,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName(last,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(examples;PatternMatching;Customer;init;,[Default]), UsedName(copy$default$1,[Default]), UsedName(first,[Default]), UsedName(eq,[Default]), UsedName(Customer,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.PatternMatching.Customer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(unapply,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName(apply$default$1,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(tupled,[Default]), UsedName(apply$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(copy,[Default]), UsedName(productElementName,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(canEqual,[Default]), UsedName(<init>$default$2,[Default]), UsedName(productElementNames,[Default]), UsedName(last,[Default]), UsedName($init$,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(curried,[Default]), UsedName(productElement,[Default]), UsedName(!=,[Default]), UsedName(productIterator,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(examples;PatternMatching;Customer;init;,[Default]), UsedName(copy$default$1,[Default]), UsedName(first,[Default]), UsedName(eq,[Default]), UsedName(Customer,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.PatternMatching.Customer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.wileLoopsTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.wileLoopsTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.wileLoopsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.wileLoopsTest,ModifiedNames(changes = UsedName(whilebreak,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(wileLoopsTest,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.wileLoopsTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(whilebreak,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(wileLoopsTest,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.wileLoopsTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Utils...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Utils[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Utils)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Utils,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(examples;Utils;init;,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(Utils,[Default]), UsedName(echo,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Utils has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(examples;Utils;init;,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(Utils,[Default]), UsedName(echo,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Utils)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.listsTests...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.listsTests[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.listsTests)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.listsTests,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(listsTests,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.listsTests has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(main,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(listsTests,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.listsTests)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.CaseClasses...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.CaseClasses[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.CaseClasses)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.CaseClasses,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(caseClass3,[Default]), UsedName(caseClass2,[Default]), UsedName(eq,[Default]), UsedName(CaseClasses,[Default]), UsedName(caseClass,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.CaseClasses has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(caseClass3,[Default]), UsedName(caseClass2,[Default]), UsedName(eq,[Default]), UsedName(CaseClasses,[Default]), UsedName(caseClass,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.CaseClasses)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.IfStatement...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.IfStatement[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.IfStatement)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.IfStatement,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(k,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(animals,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(IfStatement,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.IfStatement has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(k,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(animals,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(IfStatement,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.IfStatement)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Sets...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Sets[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Sets)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Sets,ModifiedNames(changes = UsedName(set223,[Default]), UsedName(set1,[Default]), UsedName(mutableSet1,[Default]), UsedName(sortedSet,[Default]), UsedName(listy,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(set023,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(set323,[Default]), UsedName(setBase,[Default]), UsedName(n,[Default]), UsedName(setBase2,[Default]), UsedName(synchronized,[Default]), UsedName(set123,[Default]), UsedName(greatToLower,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(set666,[Default]), UsedName(!=,[Default]), UsedName(Sets,[Default]), UsedName(sety,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(inverseSortedSet,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Sets has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(set223,[Default]), UsedName(set1,[Default]), UsedName(mutableSet1,[Default]), UsedName(sortedSet,[Default]), UsedName(listy,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName($isInstanceOf,[Default]), UsedName(set023,[Default]), UsedName(finalize,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(set323,[Default]), UsedName(setBase,[Default]), UsedName(n,[Default]), UsedName(setBase2,[Default]), UsedName(synchronized,[Default]), UsedName(set123,[Default]), UsedName(greatToLower,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(set666,[Default]), UsedName(!=,[Default]), UsedName(Sets,[Default]), UsedName(sety,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(inverseSortedSet,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Sets)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from examples.Welcome...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: examples.Welcome[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(examples.Welcome)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(examples.Welcome,ModifiedNames(changes = UsedName(Welcome,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(apply$default$2,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(examples;Welcome;init;,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The examples.Welcome has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Welcome,[Default]), UsedName(<init>$default$1,[Default]), UsedName(wait,[Default]), UsedName(equals,[Default]), UsedName(notify,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(finalize,[Default]), UsedName(apply$default$2,[Default]), UsedName(##,[Default]), UsedName(getClass,[Default]), UsedName(synchronized,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($asInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(examples;Welcome;init;,[Default]), UsedName(eq,[Default]), UsedName(ne,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(examples.Welcome)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: [0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mNo classes were invalidated.[0m
